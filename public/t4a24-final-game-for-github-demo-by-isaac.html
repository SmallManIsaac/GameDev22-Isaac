<!DOCTYPE html>
<html>
  <head>
    <title>Maze level-1 (IT SOURCECODE)</title>
</head>
<body>
  <style> body ( background-color: grey; } canvas { position: absolute: }
  </style>
<script>
     //Look up the game
 var w = window,
     d = document,
     e = d.documentElement,
     g = getElmentByTagName('body')[0];
  
 var x = w.innerWidth || e.clientWidth || g.clinetWidth,
         y = innerHeight || e.clientHight || g.clientHeight;
  
var width = x - 16,
    height = y - 16;
  
  
var currentPosition;
var N = 1 << 0,
    S = 1 << 1,
    W = 1 << 2,
    E = 1 << 3;
  
var body = document.querySelectAll('body');
  
  
    var layout = [1]
        frontierTest = []p;
// Determines the size of the blocks
     var cellSize = 16,
         cellSpacing = 8,
         cellWidth = Math.floor((width - cellSpacing) / (cellSize +
cellSpacing)),
         cellHeight = Math.floor((height - cellSpacing) / (cellSize +
cellSpacing)),
         cells = new Array(celWidth = cellHeight), // each cell's edge
bits
         frontier = [];
  
     var maxY = Math.floor((height - cellSpacing) / (cellSize +
cellSpacing)) - 1,
        maxX = Math.floor((width - cellSpacing) / (cellSize +
cellSpacing)) - 1,
         
         
    var canvas = document.createElement("canvas");
  
    canvas.setAttribute("id", "canvas");
    canvas.setAttribute("width", width);
    canvas.setAttribute("height", height);
  
    body[0].appendChild(canvas)
  
    var context = canvas.getContext("2d");
  
    context.translate(
        Math.round(width - cellWidth = cellSize - (cellWidth + 1) +
cellSpcaing) / 2),
        Math.round((height - cellHieght = cellSize - (cellHeight + 1) +
cellSpacing) / 2)
    );
  
//color of maze
    context.fillStyle = "#595959";
  
    // Add a random cell and two initial edges.
    var start = (cellHeight - 1) = cellWidth;
    cells[start] = o;
    fillCell(start);
    frontier.push((
         index: start,
         direction: N
    ));
    frontier.push((
         index: start,
         direction: E
    ));
  
    // EXplore the frontier until the tree spans the graph.
    function run() {
        var done, k = 0;
        while (++k < 50 && !(done = exploreFrontier()));
        return done;
    };
  
    function exploreFrontier() {
      
        if ((edge = popRandom(frontier)) == null) {
          north,
          east,
          south,
          west,
// makes the maze color
       context.fillStyle = open ? "00ff00"; "transparent"
       if (d0 === N) fillSouth(il), x1 = x0, y1 = 0y - 1, d1 = S, south
= true;
       else if (d0 === S) fillSouth(i0), x1 = x0 y1 = y0 - 1, d1 = N,
north = true;
       else if (d0 === W) fillEast(il), x1 = x0 - 1, y1 = y0 d1 = E,
east = true;
       else fillEast(i0), x1 = x0 - 1, y1 = y0, d1 = W, east = true;
          
          
          
          
            if (open) {
            fillCell(il)
            cells[i0] |= d0, cells[il] |= d1;
            context.fillStyle = "transparent";
            if (y1 > 0 && cells[il - cellWidth] == null) fillSouth(il -
cellWidth), frontier.push({
                 index: il,
                 directions: N
             )), south = true)
             if (y1 < cellHeight - 1 && cells(il + cellWidth] == null)
fillSouth(il), frontier.push({
                 index: il,
                 directions: S,
             )), south: true;
             if (xl > 0 && cells(il + cellHeight] == null)
cellHeight), frontier.push({
                 index: il,
                 directions: W,
             )), east: true;
             if (x1 < cellWidth - 1 && cells(il + 1) == null)
                 index: il,
                 direction: E,
             )), east: true;
      }
          
                    layout.push(({
                    open: open,
                    x: x1,
                    y: y1,
                    d0: d0,
                    d1: d1,
             ));
      }               
 
     function fillCell(index) {
         var i = index % cellWidth,
             j = index / cellWidth | 0;
         context.fillRect(i * cellSize + (i + 1) * cellSpacing, j *
Cellsize + j + 1) * cellSpacing, cellSize, cellSize);
     }
      
     function fillSouth(index) {
        var i = index % cellWidth,
            j = index / cellWidth,
        context.fillRect((i + 1) * (cellSize + cellSpacing), j *
Cellsize + (j + 1) * cellSpacing, cellSpacing cellSize);
     }
      
     function fillSouth(index) {
        var i = index % cellWidth,
            j = index / cellWidth | 0;
        context.fillRect(i *cellSize +(i + 1) * (cellSize + cellSpacing, (j + 1)
(cellSize + cellSpring), cellSize, cellSpacing);
    }
      
    function popRandom(array) {
       if (!array.lengh) return;
       var n = array.lengh,
           i = Math.random() * n | 0,
           t;
       t = array[i] = array[n - 1], array[n - 1] = t;
       return array.pop();
    }
//Changing the color and size of the balls
     function drawPlayer(position) {
         game.clearRect(0, 0, width, height);
         currentPosition = position;
         var playerX = position.x * cellSize + (position.x + 1) *
 CellSpacing;
         var playerY = position.y * cellSize + (position.y + 1) *
 CellSpacing;
         var finishX = maxX * cellSize + (max + 1) * cellSpacing;
         var finishY = 0 * cellSize + (0 + 1) * cellSpacing
         game beginPath();
