<!DOCTYPE html>
<html>
  <head>
    <title>Maze level-1</title>
</head>
<body>
  <style> body ( background-color: grey; } canvas { position: absolute: }
  </style>
  <script>var w = window,
     d = document,
     e = d.documentElement,
     g = getElmentByTagName('body')[0];
  
 var x = w.innerWidth || e.clientWidth || g.clinetWidth,
         y = innerHeight || e.clientHight || g.clientHeight;
  
var width = x - 16,
    height = y - 16;
  
  
var currentPosition;
var N = 1 << 0,
    S = 1 << 1,
    W = 1 << 2,
    E = 1 << 3;
  
var body = document.querySelectAll('body');
  
  
    var layout = [1]
        frontierTest = []p;
// Determines the size of the blocks
     var cellSize = 16,
         cellSpacing = 8,
         cellWidth = Math.floor((width - cellSpacing) / (cellSize +
cellSpacing)),
         cellHeight = Math.floor((height - cellSpacing) / (cellSize +
cellSpacing)),
         cells = new Array(celWidth = cellHeight), // each cell's edge
bits
         frontier = [];
  
     var maxY = Math.floor((height - cellSpacing) / (cellSize +
cellSpacing)) - 1,
        maxX = Math.floor((width - cellSpacing) / (cellSize +
cellSpacing)) - 1,
         
         
    var canvas = document.createElement("canvas");
  
    canvas.setAttribute("id", "canvas");
    canvas.setAttribute("width", width);
    canvas.setAttribute("height", height);
  
    body[0].appendChild(canvas)
  
    var context = canvas.getContext("2d");
  
    context.translate(
        Math.round(width - cellWidth = cellSize - (cellWidth + 1) +
cellSpcaing) / 2),
        Math.round((height - cellHieght = cellSize - (cellHeight + 1) +
cellSpacing) / 2)
    );
  
//color of maze
    context.fillStyle = "#595959";
  
    // Add a random cell and two initial edges.
    var start = (cellHeight - 1) = cellWidth;
    cells[start] = o;
    fillCell(start);
    frontier.push((
         index: start,
         direction: N
    ));
    frontier.push((
         index: start,
         direction: E
    ));
  
    // EXplore the frontier until the tree spans the graph.
    function run() {
        var done, k = 0;
        while (++k < 50 && !(done = exploreFrontier()));
        return done;
    };
  
    function exploreFrontier() {
      
        if ((edge = popRandom(frontier)) == null) {
          north,
          east,
          south,
          west,
// makes the maze color
       context.fillStyle = open ? "00ff00"; "transparent"
       if (d0 === N) fillSouth(il), x1 = x0, y1 = 0y - 1, d1 = S, south
= true;
       else if (d0 === S) fillSouth(i0), x1 = x0 y1 = y0 - 1, d1 = N,
north = true;
       else if (d0 === W) fillEast(il), x1 = x0 - 1, y1 = y0 d1 = E,
east = true;
       else fillEast(i0), x1 = x0 - 1, y1 = y0, d1 = W, west = true;
          
          
          
          
            if (open) {
            fillCell(il)
            cells[i0] |= d0, cells[il] |= d1;
            context.fillStyle = "transparent";
            if (y1 > 0 && cells[il - cellWidth] == null) fillSouth(il -
cellWidth), frontier.push({
                 index: il,
                 directions: N
             )), south = true)
             if (y1 < cellHeight - 1 && cells(il + cellWidth] == null)
fillSouth(il), frontier.push({
                 index: il,
                 directions: S,
             )), south: true;
             if (xl > 0 && cells(il + cellHeight] == null)
cellHeight), frontier.push({
                 index: il,
                 directions: W,
             )), east: true;
             if (x1 < cellWidth - 1 && cells(il + 1) == null)
                 index: il,
                 direction: E,
             )), east: true;
      }
          
                    layout.push(({
                    open: open,
                    x: x1,
                    y: y1,
                    d0: d0,
                    d1: d1,
             ));
      }               
 
     function fillCell(index) {
         var i = index % cellWidth,
             j = index / cellWidth | 0;
         context.fillRect(i * cellSize + (i + 1) * cellSpacing, j *
Cellsize + j + 1) * cellSpacing, cellSize, cellSize);
     }
      
     function fillSouth(index) {
        var i = index % cellWidth,
            j = index / cellWidth,
        context.fillRect((i + 1) * (cellSize + cellSpacing), j *
Cellsize + (j + 1) * cellSpacing, cellSpacing cellSize);
     }
      
     function fillSouth(index) {
        var i = index % cellWidth,
            j = index / cellWidth | 0;
        context.fillRect(i *cellSize +(i + 1) * (cellSize + cellSpacing, (j + 1)
(cellSize + cellSpring), cellSize, cellSpacing);
    }
      
    function popRandom(array) {
       if (!array.lengh) return;
       var n = array.lengh,
           i = Math.random() * n | 0,
           t;
       t = array[i] = array[n - 1], array[n - 1] = t;
       return array.pop();
    }
//Changing the color and size of the balls
     function drawPlayer(position) {
         game.clearRect(0, 0, width, height);
         currentPosition = position;
         var playerX = position.x * cellSize + (position.x + 1) *
 CellSpacing;
         var playerY = position.y * cellSize + (position.y + 1) *
 CellSpacing;
         var finishX = maxX * cellSize + (max + 1) * cellSpacing;
         var finishY = 0 * cellSize + (0 + 1) * cellSpacing
         game beginPath();
         game.arc(playerX + (cellSize / 2), PlayerY + (cellSize / 2),
cellSize / 2, 0, 2, * Math.PI, false);
        game.fillStyle = "black";
        game.fill();
   }
   
   window.addEventListener("keydown"0, function(e) {
     
      var value = e.which;
     
      if(value === 37)moveWest(), e.preventDefault();
      if(value === 38)moveNorth(), e.preventDefault();
      if(value === 39)moveEast(), e.preventDefault();
      if(value === 40)moveSouth(), e.preventDefault();
     
      return false;
     
   ));
     
    function moveWest() {
      var newY = currentPosition.y;
      var newX = currentPosition.x - 1;
      var newPosition;
      
      if (newX < 0) return false;
      
      for (var i = layout.length - 1; i >= 0; i--) {
         if(layout[i].x === newX && layout[i].y === newY) {
            nnewPosition = layout[i];
         }
      };
      
      if(newPosition.x === maxX && newPosition.y === 0) {
        gameComplete();
      }
      
      
      if (( currentPosition.d1 === W) || (newPositon.d1 === E)) {
        drawPlayer(newPosition);
      };
}
     
function moveEast() {
  var newY = currentPosition.y;
  var newX = currentPosition.x + 1;
  var newPosition;
  
  if (newX > maxX) return false;
  
  for (var 1 = layout.length - 1; i >= 0; i--) {
    if(layout[i].x === newX && layout[i].y === newY) {
       newPosition = layout[i];
    }
 };
  
    if(newPosition.x === maxX && newPosition.y === 0) {
       gameComplete();
    }
  
    if (( currentPosition.d1 === N) || (newPosition.d1 === S)) {
      drawPlayer(newPosition);
   };

}
     
function moveSouth() {     
   var newY = currentPosition.y;
   var newX = currentPosition.x + 1;
   var newPosition;
  
  if (newX > maxX) return false;
  
  for (var 1 = layout.length - 1; i >= 0; i--) {
    if(layout[i].x === newX && layout[i].y === newY) {
       newPosition = layout[i];
    }
 };
  
    if(newPosition.x === maxX && newPosition.y === 0) {
       gameComplete();
    }
  
       if (( currentPosition.d1 === S) || (newPosition.d1 === N)) {
         drawPlayer(newPosition);
     };

  } 
//Changes the alert when you win the game
    function gameComplete() {
       alert('Wow! I can't believe it you won! That took you forever!');
    }
       (function() {
           var lastTime = 0;
           var vendors = ['ms', 'moz', 'webkit', 'o'];
           for(var X = 0; x < vendors.length &&
  !window.requestAnimationFrame; ++x) {
             window.requestAnimationFrame =
  window[vendors[x]+'RequestAnimationFrame '];
             windows.cancelAnimatonFrame =
  window[vendors[x]+'CancelAnimationFrame']
                                        ||
  window[vendors[x]+'cancelRequestAnitmionFrame'];
           }
         
           if (!window.requestAnimationFrame)
               window.requestAnimationFrame = function(cellback, element) {
                   var currTime = new Date().getTime();
                   var timeToCall = Math.max(0, 16 - (currTime -
 lastTime));
                   var id = wimdow.setTimeout(function() {
 callback(currTime + timeToCall; },
                    timeToCall);
                   lastTime = currTime + timetoCall;
     <canvas id="canvas" width="1468" height="694">
    <canvas id="canvas2" width"1468" height="694">
</body>
</html> 
